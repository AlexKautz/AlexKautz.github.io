<!doctype html><html data-theme=light lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src 'self' player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://alexkautz.github.io name=base><title>
Alex Kautz • Paper Review: Test Coverage in Python Programs</title><link title="Alex Kautz - Atom Feed" href=https://alexkautz.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://alexkautz.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://alexkautz.github.io/main.css?h=28b3fcbb58f2f22a8c44" rel=stylesheet><meta content=light name=color-scheme><meta content='A review of the paper "Test Coverage in Python Programs" by Zhai, Casalnuovo, and Devanbu.' name=description><meta content='A review of the paper "Test Coverage in Python Programs" by Zhai, Casalnuovo, and Devanbu.' property=og:description><meta content="Paper Review: Test Coverage in Python Programs" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://alexkautz.github.io/blog/paper-review-test-coverage-in-python-programs/ property=og:url><meta content="Alex Kautz" property=og:site_name><script src="https://alexkautz.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://alexkautz.github.io/>Alex Kautz</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://alexkautz.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://alexkautz.github.io/resume/>resume </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div></ul></ul></div></nav></header><div class=content><main><article class=h-entry><h1 class="p-name article-title">Paper Review: Test Coverage in Python Programs</h1><a class="u-url u-uid" href=https://alexkautz.github.io/blog/paper-review-test-coverage-in-python-programs/></a><ul class=meta><span class="hidden p-author h-card"> <a title="Alex Kautz" class=u-url href=https://alexkautz.github.io rel=author>Alex Kautz</a> </span><li><time class=dt-published datetime=2020-08-23>23rd Aug 2020</time><li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://alexkautz.github.io/tags/unittesting/>unittesting</a>, <li class=tag><a class=p-category href=https://alexkautz.github.io/tags/paper/>paper</a>, <li class=tag><a class=p-category href=https://alexkautz.github.io/tags/academia/>academia</a></ul><p class=p-summary hidden>A review of the paper "Test Coverage in Python Programs" by Zhai, Casalnuovo, and Devanbu.<section class="e-content body"><h3 id=link-to-paper><a href=https://www.cs.ucdavis.edu/~devanbu/msr2019.pdf><strong>Link to paper</strong></a></h3><h2 id=intro>Intro</h2><p>Recently a friend suggested I combine my interests in software engineering and academia and check out the work of <a href=https://www.cs.ucdavis.edu/~devanbu/>Prem Devanbu</a>. Prem is a Professor at the University of California at Davis and a co-director of <a href=https://decallab.cs.ucdavis.edu/>the DECAL Lab</a>. Among other things, Prem analyzes both the processes of software development, and the code it produces.<p>I’m excited by this new topic! The beauty I find software development is that at its best it is exponential. People don’t just write software, they write software to help them write software, and software to help them write that. I find the thrill of accelerating my creative process addicting. I am always looking for new IDEs, obscure programming languages, and methodologies. Today’s paper covers one of the most popular catalyst’s for in software development: the humble unit test.<p>In 2019 Prem Devanbu, Casey Casalnuovo, and Hongyu Zhai published their paper “<a href=ttps://www.cs.ucdavis.edu/~devanbu/msr2019.pdf>Test Coverage in Python Programs</a>”. This paper takes a look at three of the most popular open source Python projects, and examines the code coverage of their integrated unit tests.<p>For the uninitiated, a unit test is a chunk of code designed to test the function of a piece of software you’re developing. For example if you’re creating a calculator, you might write a unit test to ensure asking <code>5 * 5</code> produces <code>25</code>, and asking <code>5 / 0</code> produces a well formatted message kindly reminding the user one can not devide by 0. For convenience, unit tests are generally written in the same language as the software being tested and are stored in the same repository. Many libraries are available to make reading unit tests easier.<p>Although it’s outside the scope of this blog post, there is an interesting software development methodology called <a href=https://en.wikipedia.org/wiki/Test-driven_development>test-driven development</a>, which as the name suggests builds software from the ground up based on testing it’s functionality.<p>One important concept when it comes to unit testing is “code coverage”. Code is “covered” when it is run during a test. So the code coverage of a project is the subset of its code that is tested by its unit tests.<p>A basic question you can ask about a project is: what percentage of the code is covered? The higher the percent, the less opportunity there is for unintended behavior to slip in in uncovered code. This has already been a research topic, and most unit testing libraries provide tools to see projects coverage percentages.<p>Prem’s paper go’s further to ask “In general, what parts of a code base are uncovered?”.<h2 id=the-paper>The Paper</h2><p><em>(I am simplifying the paper and methodology quite a bit, check out the full paper for the details.)</em><p>To answer this question, the team looked at 4 major open source python projects:<ul><li>Flask<li>Matplotlib<li>Pandas<li>Scikit-learn<li>Scrapy</ul><p>Then for each statement in the projects (for which the information was available) they noted:<ol><li>Whether the statement was covered<li>The “depth” of the statement in the code<li>The type of the statement (If, Assert, ExceptHandler, etc.)<li>How long ago the line was written<li>The line number</ol><p>1. Was obtained using a service called Codecov, that tracks code coverage for the five projects they analyzed.<p>2. and 3. Were obtained using the python Library “ast”. AST Stands for abstract syntax tree and refers to the lower-level language python “compiles” into right before running. This language takes the form of a tree, with the depth of a statement represented by its depth in the tree. Furthermore the nodes of the tree are marked with the types of the source statements.<p>4. Was found using Git, a very popular file versioning tool.<p>5. Was found by, well, counting the lines.<p>They then used a logistic regression model[5] to model a statement’s chance of being covered (1.) based on (2.) - (5.).<p>The results are summarized in their table II:<p><img alt="Table of data" src=/img/table001.png><p>The first thing to understand about this table is that the “Dependent Variable Factor” is on a logarithmic scale, so we need to plug it into <code>1-e^x</code> in order to extract its meaning. For example with ast_depth: <code>1-e^(-0.210) = 0.1894</code>.<p>Now to interpret the values:<p>For ast_depth, <code>1-e^(-0.210) = 0.1894</code> means that for every layer of depth a statement is, it gets 18.94% less likely to be covered.<p>For node_type factors, The authors compared the probability of each node type being covered against a baseline type, assignment. ( <code>x = 3</code> is an example of an assignment).<br> So a “For” type statement is <code>1-e^(-0.243) = 0.2157 = %21.57</code> less likely to be covered then an assignment.<br> A “If” type statement is <code>1-e^(0.286) = -0.3311 = -%33.11</code> less likely to be covered then an assignment. note this percentage is negative, so really A “If” type statement is <code>%33.11</code> more likely to be covered then a assignment.<br> A “Exception Handler” type statement is <code>1-e^(-1.680) = 0.8136 = %81.36</code> less likely to be covered then an assignment.<br> And so on.<p>The authors point out the results on the effect of the depth of a statement and whether the statement is an Exception Handler has on its chance of being covered as important.<h2 id=analysis>Analysis</h2><p>Unit testing is a powerful technique. While working as a intern for <a href=https://www.1010data.com/>1010Data</a>, it helped me in two ways:<ul><li>Caching bugs and newly broken code as I implemented new features and fixed old ones.<li>Helping me understand the problem deeper as I wrote new unit tests.</ul><p>These two features worked in harmony as I used test-driven development. This means I would write tests for a certain problem before the code to solve it. The tests I found hardest to write were one that required lots of setup to even get the program into a state where it could perform what I was testing.<p>This paper validates that experience since two of the categories of code that requires the most setup to test are:<ul><li>Code that is deep in the syntax<li>Code that handles exceptions</ul><p>Code that is deep in syntax requires setting a whole host of variables so the code pointer can even make it past the various if and switch statements. As for exceptions, I found I had to make modifications to the simulation environment chest to push the code to break. For example I had to create a fake database in order to test database read and write exception handling.<p>It makes sense then that unit tests that are harder to write are also the ones that are written less. Furthermore, the less time and energy a company wants to put into unit testing, the more these harder to test statements will be missed. The fallacy people think is “if a line of code is hard to test, it must not run frequently, and so it is not as important as lines that are easy to test”.<p>One solution to this is to construct more powerful unit testing tools and libraries, which features targeting exception handling and deep statements. For example, a program that upon selecting a line in an IDE will generate a boilerplate unit test that runs that line. Then the programmer needs only to enter the expected output. This can help with deeply nested statements.<p>Making exception handling testing easier requires a greater focus on the environment in which you test your program. The Python Library “mock” is already powerful enough for this, so maybe a rapper to allow using it in fewer lines or making it simpler would be effective.<p>In any case this paper was very interesting. I’m really excited to see other ways that software engineering can be studied from an academic perspective.</section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://alexkautz.github.io/blog/paper-review-test-coverage-in-python-programs/#link-to-paper>Link to paper</a><li><a href=https://alexkautz.github.io/blog/paper-review-test-coverage-in-python-programs/#intro>Intro</a><li><a href=https://alexkautz.github.io/blog/paper-review-test-coverage-in-python-programs/#the-paper>The Paper</a><li><a href=https://alexkautz.github.io/blog/paper-review-test-coverage-in-python-programs/#analysis>Analysis</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://alexkautz.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/AlexKautz/AlexKautz.github.io> <img alt=github loading=lazy src=https://alexkautz.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://www.linkedin.com/in/alex-kautz/> <img alt=linkedin loading=lazy src=https://alexkautz.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>